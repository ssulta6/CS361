#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

/*
    CS 361 HW2 instructions:
    - Display a command prompt and read in a command line from the user
    - Parse the command line into arguments, creating an array of character pointers, where array[0] points to the actual command and rest of the array elements point to the arguments to the command (Similar to main()â€™s argv[])
    - Fork off a child and have the child load the requested program by passing the argument vector created in step 2 to exec() family of system calls. The parent should report the PID of the child before proceeding to the next step.
    - Wait for the child to complete executing and report why it ended (exited or uncaught signal) and its exit value if available.
    - Repeat for first step forever till user enters the command exit
    - Your shell should also support basic I/O redirection line the Unix shell.
    - $ command > filename Redirects the output of command to filename. The existing contents of filename are overwritten.
    - $ command >> filename` Redirects the output of command to filename. The output from command is appended to contents of filename. Existing contents are not overwritten.
    - $ command < filename Command reads its input from filename instead of from stdin.
    - Your shell should handle the following signals:
    - SIGINT - Generated by Ctrl-C. This signal allows a user to terminate a running program. Your shell should not exit when user presses Ctrl-C but simply report that SIGINT signal has been received by the shell.
    - SIGTSTP - Generated by Ctrl-Z. Your shell should not exit when user presses Ctrl-Z but simply report that SIGTSTP signal has been received by the shell.
    - The shell need not support background processes or running more than one child at a time.
*/

/*
 * Author: Basheer Subei
 * CS 361 HW2 Fall 2015
 *
 * This program is a simple shell (called bashsh, or Basheer's shell) that takes commands
 * and runs them in child processes.
 *
 * Some example code was taken from the official C/C++ library documentation.
 */


// returns number of tokens for given char*. Uses space as delimiter.
int get_token_count(char * input) {
    int count = 0;
    char * temp;
    temp = strtok(input, " ");
    while (temp != NULL) {
        temp = strtok(NULL, " ");
        count++;
    }
    return count;
}


int main(int argc, char *argv[]) {

    printf("Welcome to bashsh, Basheer's shell... Enter your commands:\n");

    while(1) {
    // display prompt
    printf("bashsh $ ");


    // create a char pointer to hold in command and arguments
    char input[100];

    // read in line of input
    fgets(input, 100, stdin);
    char input_copy[100];
    strcpy(input_copy, input);

    // remove newline char
    char *newline_char_ptr = strchr(input, '\n');
    *newline_char_ptr = ' ';

    // count number of tokens
    int num_tokens = get_token_count(input_copy);

    // create array of char pointers to store tokens, one extra char pointer at end for execv()
    char * current_token;
    char **tokens = (char **)malloc(sizeof(char *) * num_tokens + 1);
    // parse the input and fill up the char pointers with the tokens
    current_token = strtok(input, " ");
    int i;
    for (i = 0; i < num_tokens; i++) {
        // printf("%d: %s\n", i, current_token);  // DEBUG
        // create space for new token and copy it
        tokens[i] = (char *)malloc(sizeof(char) * strlen(current_token));
        // TODO valgrind gives error on tokens[i] access
        strcpy(tokens[i], current_token);

        // get next token
        current_token = strtok(NULL, " ");
    }

    // fill up last token as NULL pointer (for execv())
    tokens[num_tokens] = (char *)0;


    // fork a child and exec() command
    pid_t pid = fork();

    // if failed fork
    if (pid < 0) {
        printf("Failed to fork process!\n");
        exit(-1);
    // if this is child process, call exec()
    } else if (pid == 0) {

        // check all tokens for redirection symbols, don't check last token.
        for (i = 1; i < num_tokens - 1; i++) {
            // output redirection with appending
            if (strcmp(tokens[i], ">>") == 0) {
                const char *filename = tokens[i + 1];
                printf("Switching stdout using freopen\n");
                freopen(filename, "a", stdout);

                break;
            // output redirection without appending
            } else if (strcmp(tokens[i], ">") == 0) {
                const char *filename = tokens[i + 1];
                printf("Switching stdout using freopen\n");
                freopen(filename, "a", stdout);

                break;
            // input redirection
            } else if (strcmp(tokens[i], "<") == 0) {

                break;
            }
        }

        // clean the tokens to exclude or remove the redirection arguments and whatever is after them
        // note: i is the index to redirection token. The extra one element is for last NULL element for execv()
        int num_clean_tokens = i+1;
        char **clean_tokens = malloc(sizeof(char *) * num_clean_tokens);
        int count;
        // make shallow copy of clean tokens (no need for deep copy)
        for (count = 0; count < i; count++)
            clean_tokens[count] = tokens[count];
        // fill up last element with NULL char (for execv)
        clean_tokens[i] = (char *)0;

        execv(clean_tokens[0], clean_tokens);

        free(clean_tokens);

        // need to kill child when done
        exit(0);

    // if parent, wait for child to finish
    } else {
        printf("Child PID: %d\n", pid);
        // printf("Hello, World from parent!\n");
        wait(NULL);
    }

    // free memory that held previous command
    for (i = 0; i < num_tokens; i++)
        free(tokens[i]);
    free(tokens);

    // report result, repeat above

    }
    return 0;
}

// catch signals

